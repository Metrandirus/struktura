<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>–û—Ä–≥—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ ‚Äî —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
  <style>
    :root{
      --bg:#0f1220; --panel:#171a2b; --panel-2:#0d1020; --text:#eaf0ff; --muted:#9aa3b2; --border:#232947; --accent:#7aa2ff; --danger:#ff6b6b; --titlebg:#0a1028;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:var(--text);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial}
    .app{display:grid;grid-template-rows:auto 1fr; height:100%}
    .topbar{display:flex;gap:8px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--border);background:linear-gradient(180deg,var(--panel),var(--panel-2));position:sticky;top:0;z-index:10}
    .topbar .right{margin-left:auto;display:flex;gap:8px}
    .btn{border:1px solid var(--border);background:#12162a;color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer;transition:.15s}
    .btn:hover{border-color:#2f3868;transform:translateY(-1px)}
    .btn.primary{background:linear-gradient(180deg,#2a3370,#1e2655);border-color:#364080}
    .btn.warn{background:linear-gradient(180deg,#5e2b2b,#441d1d);border-color:#7a3030}
    .btn.small{padding:6px 8px;font-size:12px}
    .sep{flex:0 0 1px;height:32px;background:var(--border);margin:0 6px}

    .stage-wrap{position:relative;overflow:auto}
    .toolbar{position:absolute;top:12px;left:12px;display:none;gap:8px;padding:8px;border-radius:12px;background:#0c1022;border:1px solid var(--border);box-shadow:0 1px 0 rgba(0,0,0,.4);z-index:5}
    .badge{display:inline-block;padding:4px 8px;border:1px solid var(--border);border-radius:999px;background:#12162a;color:var(--muted)}

    .dialog{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:20}
    .dialog .card{width:min(460px,90vw);background:#0c1022;border:1px solid var(--border);border-radius:16px;padding:14px}
    .row{display:flex;gap:8px}
    label{display:block;margin:8px 0 4px;color:var(--muted)}
    input{width:100%;padding:8px 10px;border:1px solid var(--border);background:#0b0f22;color:var(--text);border-radius:10px}

    .stage{width:2200px;height:1400px;background:repeating-conic-gradient(from 0deg, #10142a 0 25%, #0e1226 0 50%) 0 0/24px 24px; border-bottom-left-radius:12px;border-bottom-right-radius:12px}
    svg{display:block}
    .node rect.body{fill:#101735;stroke:#2d3a70;stroke-width:2;rx:12;ry:12}
    .node rect.title{fill:#0d163a;stroke:#2d3a70;stroke-width:2;rx:0;ry:0}
    .node .name{font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial;fill:#eaf0ff;font-weight:700}
    .node .role{font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;fill:#cfe0ff}
    .node.selected rect.body{stroke:#7aa2ff}
    .org rect{fill:#16225a;stroke:#6a7eea;stroke-width:2;rx:14;ry:14}
    .edge{stroke:#3a9ad9;stroke-width:2;fill:none}
    .edge.selected{stroke:#7aa2ff}
    .rubber{stroke:#ffb86b;stroke-dasharray:6 4}
    .hint{position:absolute;right:12px;bottom:12px;color:var(--muted);background:rgba(0,0,0,.25);padding:6px 10px;border-radius:10px;border:1px solid var(--border)}
  </style>
</head>
<body>
  <div class="app">
    <div class="topbar">
      <div class="left">
        <strong>–û—Ä–≥—Å—Ç—Ä—É–∫—Ç—É—Ä–∞</strong>
        <span id="saveBadge" class="badge" style="margin-left:8px">–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ</span>
      </div>
      <div class="right">
        <button id="autoLayoutBtn" class="btn">üìê –ê–≤—Ç–æ–≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ</button>
        <button id="exportPngBtn" class="btn">üñºÔ∏è PNG</button>
        <button id="editBtn" class="btn primary">‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ</button>
      </div>
    </div>

    <div class="stage-wrap" id="stageWrap">
      <div class="toolbar" id="toolbar">
        <button id="addNodeBtn" class="btn small">‚ûï –°–æ—Ç—Ä—É–¥–Ω–∏–∫</button>
        <button id="drawEdgeBtn" class="btn small">‚úíÔ∏è –†–∏—Å–æ–≤–∞—Ç—å —Å—Ç—Ä–µ–ª–∫—É</button>
        <button id="eraseEdgeBtn" class="btn small warn">üßΩ –°—Ç–∏—Ä–∞—Ç—å —Å—Ç—Ä–µ–ª–∫—É</button>
        <button id="deleteNodeBtn" class="btn small warn">üóëÔ∏è –£–¥–∞–ª–∏—Ç—å —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞</button>
        <span id="modeBadge" class="badge">–†–µ–∂–∏–º: –≤—ã–±–æ—Ä</span>
      </div>

      <svg id="stage" class="stage" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2200 1400">
        <defs>
          <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
            <path d="M 0 0 L 10 5 L 0 10 z" fill="#3a9ad9"></path>
          </marker>
        </defs>
        <g id="edges"></g>
        <g id="nodes"></g>
        <g id="org" class="org" transform="translate(960,40)">
          <rect x="0" y="0" width="280" height="60" rx="14" ry="14"></rect>
          <text id="orgText" x="140" y="36" text-anchor="middle" style="font-weight:700;fill:#eaf0ff">–ú–æ—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è</text>
        </g>
      </svg>
      <div class="hint">–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: –≤–∫–ª—é—á–∏—Ç–µ ¬´‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ¬ª. –†–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏ ‚Äî –∑–∞–∂–º–∏—Ç–µ –Ω–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–µ –∏ –≤–µ–¥–∏—Ç–µ –¥–æ —Ü–µ–ª–∏. –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –ø–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫—É ‚Äî —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å.</div>
    </div>
  </div>

  <div id="dialog" class="dialog">
    <div class="card">
      <h3 style="margin:0 0 8px">–°–æ—Ç—Ä—É–¥–Ω–∏–∫</h3>
      <label>–§–ò–û</label>
      <input id="inpName" placeholder="–ù–∞–ø—Ä.: –ò–≤–∞–Ω –ü–µ—Ç—Ä–æ–≤" />
      <label>–î–æ–ª–∂–Ω–æ—Å—Ç—å</label>
      <input id="inpTitle" placeholder="–ù–∞–ø—Ä.: –†—É–∫–æ–≤–æ–¥–∏—Ç–µ–ª—å –æ—Ç–¥–µ–ª–∞" />
      <div class="row" style="margin-top:10px">
        <button id="dlgSave" class="btn primary" style="flex:1">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
        <button id="dlgCancel" class="btn" style="flex:1">–û—Ç–º–µ–Ω–∞</button>
      </div>
    </div>
  </div>

  <script>
  // ===== –ú–æ–¥–µ–ª—å =====
  const STORAGE_KEY = 'orgchart_svg_v2';
  const state = load() || { orgName: '–ú–æ—è –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è', nodes: [], edges: [] };

  // ===== DOM =====
  const stage = document.getElementById('stage');
  const gNodes = document.getElementById('nodes');
  const gEdges = document.getElementById('edges');
  const org = document.getElementById('org');
  const orgText = document.getElementById('orgText');
  const toolbar = document.getElementById('toolbar');
  const modeBadge = document.getElementById('modeBadge');
  const saveBadge = document.getElementById('saveBadge');

  const autoLayoutBtn = document.getElementById('autoLayoutBtn');
  const editBtn = document.getElementById('editBtn');
  const exportPngBtn = document.getElementById('exportPngBtn');
  const addNodeBtn = document.getElementById('addNodeBtn');
  const drawEdgeBtn = document.getElementById('drawEdgeBtn');
  const eraseEdgeBtn = document.getElementById('eraseEdgeBtn');
  const deleteNodeBtn = document.getElementById('deleteNodeBtn');

  const dialog = document.getElementById('dialog');
  const inpName = document.getElementById('inpName');
  const inpTitle = document.getElementById('inpTitle');
  const dlgSave = document.getElementById('dlgSave');
  const dlgCancel = document.getElementById('dlgCancel');

  // ===== –†–µ–∂–∏–º—ã =====
  let editMode = false;
  let drawEdgeMode = false;
  let eraseEdgeMode = false;
  let selectedNodeId = null;
  let drag = null; // {id, dx, dy}
  let rubber = null; // –≤—Ä–µ–º–µ–Ω–Ω–∞—è –ª–∏–Ω–∏—è {el, from}
  let editingNodeId = null; // –µ—Å–ª–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ

  // ===== –£—Ç–∏–ª–∏—Ç—ã =====
  function uid(){ return 'n' + Math.random().toString(36).slice(2,9); }
  function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); showSaved(); }
  function load(){ try{ const raw=localStorage.getItem(STORAGE_KEY); return raw? JSON.parse(raw):null; }catch(e){ return null; } }
  function showSaved(){ saveBadge.textContent = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ'; setTimeout(()=> saveBadge.textContent=' ', 1200); }
  function getNode(id){ return state.nodes.find(n=>n.id===id); }
  function removeNode(id){ state.nodes = state.nodes.filter(n=>n.id!==id); state.edges = state.edges.filter(e=> e.from!==id && e.to!==id); }
  function edgeExists(from,to){ return state.edges.some(e=>e.from===from && e.to===to); }
  function wouldCycle(sourceId, targetId){
    const parentsOf = new Map();
    state.edges.forEach(e=>{ const arr = parentsOf.get(e.to)||[]; arr.push(e.from); parentsOf.set(e.to,arr); });
    const stack=[sourceId]; const seen=new Set();
    while(stack.length){ const cur=stack.pop(); if(seen.has(cur)) continue; seen.add(cur); if(cur===targetId) return true; const ps = parentsOf.get(cur)||[]; stack.push(...ps); }
    return false;
  }

  // –ò–∑–º–µ—Ä–µ–Ω–∏–µ –∏ –∞–≤—Ç–æ-—Ä–∞–∑–º–µ—Ä—ã —É–∑–ª–∞: –≤–µ—Ä—Ö ‚Äî –∏–º—è (14px), –Ω–∏–∑ ‚Äî –¥–æ–ª–∂–Ω–æ—Å—Ç—å (12px, —Ç—ë–º–Ω—ã–π —Ñ–æ–Ω)
  function fitNodeSize(n){
    const padX = 16; const nameWidth = Math.max( (n.name||'').length*8 + padX*2, 180 );
    const roleWidth = Math.max( (n.title||'').length*7 + padX*2, 180 );
    const w = Math.min(420, Math.max(nameWidth, roleWidth));
    const nameH = 28; const roleH = 24; // —Ñ–∏–∫—Å. –≤—ã—Å–æ—Ç—ã –∑–æ–Ω
    n.w = w; n.h = nameH + roleH;
  }

  // ===== –†–∏—Å–æ–≤–∞–Ω–∏–µ =====
  function draw(){
    orgText.textContent = state.orgName || '–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è';

    gNodes.innerHTML = '';
    for(const n of state.nodes){
      fitNodeSize(n);
      const g = svgEl('g', {class:'node', transform:`translate(${n.x},${n.y})`}); g.dataset.id = n.id;
      const body = svgEl('rect', {class:'body', x:0, y:0, width:n.w, height:n.h, rx:12, ry:12});
      const splitY = n.h - 24; // –ª–∏–Ω–∏—è —Ä–∞–∑–¥–µ–ª–∞
      const titleRect = svgEl('rect', {class:'title', x:0, y:splitY, width:n.w, height:24});
      const nameText = svgEl('text', {x:12, y:18, class:'name'}); nameText.textContent = n.name||'';
      const roleText = svgEl('text', {x:12, y:splitY+16, class:'role'}); roleText.textContent = n.title||'';
      g.append(body, titleRect, nameText, roleText);
      g.addEventListener('pointerdown', nodePointerDown);
      g.addEventListener('dblclick', nodeDblClick);
      gNodes.appendChild(g);
    }

    gEdges.innerHTML = '';
    for(const e of state.edges){
      const a = getNode(e.from), b=getNode(e.to); if(!a||!b) continue;
      const x1 = a.x + a.w/2, y1 = a.y + a.h/2;
      const x2 = b.x + b.w/2, y2 = b.y + b.h/2;
      const line = svgEl('line', {x1, y1, x2, y2, class:'edge', 'marker-end':'url(#arrow)'}); line.dataset.id = e.id;
      line.addEventListener('click', edgeClick);
      gEdges.appendChild(line);
    }
  }

  function svgEl(tag, attrs){ const el=document.createElementNS('http://www.w3.org/2000/svg', tag); for(const k in attrs){ el.setAttribute(k, attrs[k]); } return el; }

  function updateEdgesNear(nodeId){
    const lines = gEdges.querySelectorAll('line');
    lines.forEach(line=>{
      const e = state.edges.find(x=>x.id===line.dataset.id); if(!e) return;
      const s = getNode(e.from), t=getNode(e.to); if(!s||!t) return;
      line.setAttribute('x1', s.x + s.w/2); line.setAttribute('y1', s.y + s.h/2);
      line.setAttribute('x2', t.x + t.w/2); line.setAttribute('y2', t.y + t.h/2);
    });
  }

  // ===== –í—ã–¥–µ–ª–µ–Ω–∏–µ =====
  function clearSelection(){ selectedNodeId = null; const sel = gNodes.querySelector('.node.selected'); if(sel) sel.classList.remove('selected'); gEdges.querySelectorAll('.edge.selected').forEach(e=>e.classList.remove('selected')); }
  function selectNode(id){ clearSelection(); selectedNodeId = id; const g = [...gNodes.children].find(x=>x.dataset.id===id); if(g) g.classList.add('selected'); }

  // ===== –£–∑–ª—ã: drag, dblclick =====
  function nodePointerDown(ev){
    if(!editMode) return;
    const g = ev.currentTarget; const id = g.dataset.id; selectNode(id);
    const n = getNode(id); const pt = getSvgPoint(ev);
    if(drawEdgeMode){ // —Å—Ç–∞—Ä—Ç —Ä–µ–∑–∏–Ω–∫–∏
      startRubberFrom(n, pt);
      return; // –Ω–µ –¥–≤–∏–≥–∞–µ–º –≤ —Ä–µ–∂–∏–º–µ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
    }
    const dx = pt.x - n.x, dy = pt.y - n.y; drag = { id, dx, dy };
    window.addEventListener('pointermove', nodePointerMove);
    window.addEventListener('pointerup', nodePointerUp, { once:true });
  }
  function nodePointerMove(ev){ if(!drag) return; const n=getNode(drag.id); const pt=getSvgPoint(ev); n.x=pt.x-drag.dx; n.y=pt.y-drag.dy; const g=[...gNodes.children].find(x=>x.dataset.id===n.id); if(g){ g.setAttribute('transform',`translate(${n.x},${n.y})`);} updateEdgesNear(n.id); }
  function nodePointerUp(){ drag=null; save(); }
  function nodeDblClick(ev){ if(!editMode) return; const id=ev.currentTarget.dataset.id; const n=getNode(id); editingNodeId=id; openDialog(n.name||'', n.title||''); }

  // ===== –†–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏ —Ä–µ–∑–∏–Ω–∫–æ–π =====
  function startRubberFrom(node, pt){
    endRubber();
    rubber = { from: node.id, el: svgEl('line', {x1: node.x+node.w/2, y1: node.y+node.h/2, x2: pt.x, y2: pt.y, class:'edge rubber'}) };
    gEdges.appendChild(rubber.el);
    window.addEventListener('pointermove', rubberMove);
    window.addEventListener('pointerup', rubberUp, { once:true });
  }
  function rubberMove(ev){ if(!rubber) return; const pt=getSvgPoint(ev); rubber.el.setAttribute('x2', pt.x); rubber.el.setAttribute('y2', pt.y); }
  function rubberUp(ev){
    if(!rubber) return; const startId = rubber.from; const el = document.elementFromPoint(ev.clientX, ev.clientY);
    const g = el && el.closest && el.closest('g.node');
    if(g){ const targetId = g.dataset.id; if(targetId!==startId){
        if(edgeExists(startId,targetId)) alert('–¢–∞–∫–∞—è —Å–≤—è–∑—å —É–∂–µ –µ—Å—Ç—å.');
        else if(wouldCycle(startId,targetId)) alert('–ù–µ–ª—å–∑—è —Å–æ–∑–¥–∞—Ç—å —Ü–∏–∫–ª.');
        else { state.edges.push({ id:'e_'+uid(), from:startId, to:targetId }); draw(); save(); }
      }
    }
    endRubber();
  }
  function endRubber(){ if(!rubber) return; rubber.el.remove(); rubber=null; }

  // ===== –ö–ª–∏–∫–∏ –ø–æ —Ä—ë–±—Ä–∞–º =====
  function edgeClick(ev){ if(!editMode) return; if(!eraseEdgeMode){ ev.currentTarget.classList.toggle('selected'); return; } const id=ev.currentTarget.dataset.id; state.edges = state.edges.filter(e=>e.id!==id); draw(); save(); }

  function getSvgPoint(ev){ const pt = stage.createSVGPoint(); pt.x = ev.clientX; pt.y = ev.clientY; return pt.matrixTransform(stage.getScreenCTM().inverse()); }

  // ===== –í–≤–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å =====
  editBtn.addEventListener('click', ()=>{ editMode = !editMode; toolbar.style.display = editMode? 'flex':'none'; editBtn.textContent = editMode? '‚úÖ –ì–æ—Ç–æ–≤–æ' : '‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ'; drawEdgeMode=false; eraseEdgeMode=false; endRubber(); modeBadge.textContent='–†–µ–∂–∏–º: –≤—ã–±–æ—Ä'; });
  exportPngBtn.addEventListener('click', exportPNG);
  autoLayoutBtn.addEventListener('click', autoLayout);

  // ===== –¢—É–ª–±–∞—Ä =====
  addNodeBtn.addEventListener('click', ()=>{ if(!editMode){ alert('–í–∫–ª—é—á–∏—Ç–µ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.'); return; } editingNodeId=null; openDialog('', ''); });
  drawEdgeBtn.addEventListener('click', ()=>{ if(!editMode){ alert('–í–∫–ª—é—á–∏—Ç–µ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.'); return; } drawEdgeMode=!drawEdgeMode; eraseEdgeMode=false; endRubber(); modeBadge.textContent = drawEdgeMode? '–†–µ–∂–∏–º: —Ä–∏—Å–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏' : '–†–µ–∂–∏–º: –≤—ã–±–æ—Ä'; });
  eraseEdgeBtn.addEventListener('click', ()=>{ if(!editMode){ alert('–í–∫–ª—é—á–∏—Ç–µ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.'); return; } eraseEdgeMode=!eraseEdgeMode; drawEdgeMode=false; endRubber(); modeBadge.textContent = eraseEdgeMode? '–†–µ–∂–∏–º: —Å—Ç–∏—Ä–∞–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏' : '–†–µ–∂–∏–º: –≤—ã–±–æ—Ä'; });
  deleteNodeBtn.addEventListener('click', ()=>{ if(!editMode){ alert('–í–∫–ª—é—á–∏—Ç–µ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.'); return; } if(!selectedNodeId){ alert('–í—ã–±–µ—Ä–∏—Ç–µ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞.'); return; } if(!confirm('–£–¥–∞–ª–∏—Ç—å –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —Å–æ—Ç—Ä—É–¥–Ω–∏–∫–∞?')) return; removeNode(selectedNodeId); clearSelection(); draw(); save(); });

  // ===== –î–∏–∞–ª–æ–≥ =====
  function openDialog(name,title){ dialog.style.display='flex'; inpName.value=name||''; inpTitle.value=title||''; inpName.focus(); }
  dlgCancel.addEventListener('click', ()=> dialog.style.display='none');
  dlgSave.addEventListener('click', ()=>{
    const name = inpName.value.trim(); if(!name){ alert('–í–≤–µ–¥–∏—Ç–µ –§–ò–û'); return; }
    const title = inpTitle.value.trim();
    if(editingNodeId){ const n = getNode(editingNodeId); n.name=name; n.title=title; fitNodeSize(n); draw(); save(); editingNodeId=null; dialog.style.display='none'; return; }
    const x = 200 + Math.random()*200, y = 160 + Math.random()*120; const n = { id: uid(), name, title, x, y, w:200, h:52 }; fitNodeSize(n); state.nodes.push(n); dialog.style.display='none'; draw(); save();
  });

  // ===== –ê–≤—Ç–æ–≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ —Å—Ç—Ä–æ–∫–∞–º =====
  function autoLayout(){
    // —É—Ä–æ–≤–Ω–∏ = —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –∫–æ—Ä–Ω—è (—É–∑–ª—ã –±–µ–∑ –≤—Ö–æ–¥—è—â–∏—Ö —Ä—ë–±–µ—Ä)
    const indeg = new Map(state.nodes.map(n=>[n.id,0]));
    state.edges.forEach(e=> indeg.set(e.to, (indeg.get(e.to)||0)+1));
    const roots = state.nodes.filter(n=> (indeg.get(n.id)||0)===0);
    const level = new Map();
    const queue = [...roots]; roots.forEach(r=> level.set(r.id, 0));
    while(queue.length){
      const cur = queue.shift(); const curLvl = level.get(cur.id)||0;
      const children = state.edges.filter(e=>e.from===cur.id).map(e=> getNode(e.to)).filter(Boolean);
      for(const ch of children){ if(!level.has(ch.id)){ level.set(ch.id, curLvl+1); queue.push(ch); } }
    }
    // –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ
    for(const n of state.nodes){ if(!level.has(n.id)) level.set(n.id, 0); }

    // –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ —É—Ä–æ–≤–Ω—è–º
    const groups = new Map();
    for(const n of state.nodes){ fitNodeSize(n); const l=level.get(n.id)||0; if(!groups.has(l)) groups.set(l,[]); groups.get(l).push(n); }

    const centerX = 1100; const vSpace = 100; const hGap = 40; let maxY = 120;
    const levels = [...groups.keys()].sort((a,b)=>a-b);
    for(const l of levels){
      const arr = groups.get(l).sort((a,b)=> a.x - b.x); // —Å—Ç–∞–± –ø–æ —Ç–µ–∫—É—â–µ–º—É –ø–æ–ª–æ–∂–µ–Ω–∏—é
      // —Å—É–º–º–∞—Ä–Ω–∞—è —à–∏—Ä–∏–Ω–∞
      let totalW = arr.reduce((s,n)=> s+n.w, 0) + hGap*(Math.max(0,arr.length-1));
      let x = centerX - totalW/2;
      for(const n of arr){ n.x = Math.round(x); n.y = Math.round(160 + l*(n.h + vSpace)); x += n.w + hGap; }
      maxY = Math.max(maxY, 160 + l*(arr[0]?.h||52) + 60);
    }
    draw(); save();
  }

  // ===== –ü—Ä–æ—á–µ–µ =====
  org.addEventListener('click', ()=>{ if(!editMode) return; const v = prompt('–ù–∞–∑–≤–∞–Ω–∏–µ –æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏–∏:', state.orgName||''); if(v!=null){ state.orgName = v.trim() || '–û—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è'; draw(); save(); } });
  stage.addEventListener('click', ()=>{ if(!editMode) return; clearSelection(); });
  window.addEventListener('keydown', (e)=>{ if(!editMode) return; if(e.key==='Delete' && selectedNodeId){ removeNode(selectedNodeId); clearSelection(); draw(); save(); } });

  function exportPNG(){
    const bbox = stage.getBBox(); const margin = 24; const w = Math.max(600, bbox.width + margin*2); const h = Math.max(300, bbox.height + margin*2);
    const clone = stage.cloneNode(true); clone.setAttribute('viewBox', `${bbox.x - margin} ${bbox.y - margin} ${w} ${h}`); clone.setAttribute('width', w); clone.setAttribute('height', h); clone.setAttribute('style', getComputedStyle(stage).cssText);
    const svgData = new XMLSerializer().serializeToString(clone); const svgBlob = new Blob([svgData], {type:'image/svg+xml;charset=utf-8'}); const url = URL.createObjectURL(svgBlob);
    const img = new Image(); img.onload = () => { const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h; const ctx = canvas.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,w,h); ctx.drawImage(img, 0,0); URL.revokeObjectURL(url); canvas.toBlob(blob => { const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'orgchart.png'; a.click(); setTimeout(()=> URL.revokeObjectURL(a.href), 1000); }, 'image/png'); }; img.src = url;
  }

  function getSvgPoint(ev){ const pt = stage.createSVGPoint(); pt.x = ev.clientX; pt.y = ev.clientY; return pt.matrixTransform(stage.getScreenCTM().inverse()); }

  // ===== –°—Ç–∞—Ä—Ç =====
  draw();

  </script>
</body>
</html>
